Этот проект — классический пример реализации реактивного UI с использованием связки Room + LiveData + ViewModel.
Если кратко: приложение позволяет сохранять текст в локальную базу данных и автоматически отображает последнюю запись на экране без необходимости вручную обновлять UI при каждом сохранении.
Основные компоненты и их функции:
1. База данных (Room):
◦ StringEntity: Простая модель данных (таблица), которая хранит id и строку текста.
◦ StringEntityDAO: здесь самое интересное. Метод getLastData() возвращает не просто объект, а LiveData<StringEntity>. Это заставляет Room "следить" за базой: как только в таблицу добавятся новые данные, LiveData сама оповестит об этом подписчиков.
2. MainActivityViewModel (Слой логики):
◦ Хранит ссылку на stringLiveData из DAO.
◦ Содержит метод putDataToDB, который сохраняет данные в БД. Обратите внимание: запись происходит в фоновом потоке (Executors.newSingleThreadExecutor()), так как Room запрещает тяжелые операции в главном (UI) потоке.
3. MainActivity (Интерфейс):
◦ Подписка (Observe): В onCreate код mainActivityViewModel.stringLiveData.observe(this) { ... } настраивает "слушателя". Как только в базе появляется новая запись (или меняется старая), текст на экране (textLastDbValue) обновляется автоматически.
◦ Ввод данных: По нажатию на кнопку текст из editText упаковывается в StringEntity и отправляется в ViewModel для сохранения.
Как это работает для пользователя:
1. Вы вводите текст в поле.
2. Нажимаете кнопку.
3. Данные улетают в SQLite.
4. Room видит изменения в таблице и "пробрасывает" их через LiveData во ViewModel, а та — в Activity.
5. Текст на экране обновляется.
